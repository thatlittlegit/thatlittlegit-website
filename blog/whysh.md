---
title: Why Shell Scripts and AWK?
date: 2018-05-21

---

In my opinion, **shell scripts are easier to understand and code.** For
example, assume you have an address book as follows:

```
John Doe      18002672001     john.net
Steve Doe     18002672002     steve.com
```

Then, perhaps you want a system with a prompt that will let you get the name,
site or phone number from a person by an ID (the line it is on) or name. I'll
show how this can be done in Node.js, C and Shell.

## Quick Note

The following section will show what a session can or should look like:

```
phone> 1
John Doe      18002672001     john.net
phone> 1 phone
18002672001
phone> 2 site
steve.com
phone> 2 name
Steve Doe
phone> license
phone-cli is (c) 2018 thatlittlegit, and is under the GNU General Public
License, 3.0 or higher.
phone> 1 qwerty
field not found
phone> 10 name
entry not found
phone> q
[exit]
```

The contacts file should also be in the user's home directory. `^D` *can* quit,
but doesn't have to.

*Lines of code generated by `cloc`. [Code downloads here](../code)*

## Node.js
```javascript
// Note: this could probably be done faster with libraries.
// I'm doing this with only Node.

const rl = require('readline').createInterface({
	input: process.stdin,
	output: process.stdout
});

// Parse the file
const file = require('fs').readFileSync(require('path').join(require('os').homedir(), 'contacts'), 'utf-8');
const contacts = file.split('\n').map((line) => line.split('\t')).map((contact) => ({
	name: contact[0],
	phone: contact[1],
	site: contact[2]
}));

function main() {
	rl.question('phone> ', (input) => {
		if (input === '') {
		} else if (input === 'q') {
			process.exit(0);
		} else if (input === 'license') {
			console.log('phone-cli is (c) 2018 thatlittlegit, and is under the GNU General Public License, 3.0 or higher.');
		} else {
			const contact = contacts[Number(input.split(' ')[0]) - 1];
			const split = input.split(' ');

			if (typeof contact === 'undefined') {
				console.error('entry not found');
			} else if (split.length === 1) {
				// They need a line
				console.log(file.split('\n')[Number(input.split(' ')[0]) - 1]);
			} else {
				// They need a field
				switch (split[1]) {
				case 'name':
					console.log(contact.name);
					break;
				case 'phone':
					console.log(contact.phone);
					break;
				case 'site':
					console.log(contact.site);
					break;
				default:
					console.error('field not found');
				}
			}
	}
	main();
	});
}

main();
```

Result: **44** lines of code (actually 54).

## C

```c
// Note: This program only supports contact-paths below 32 bytes, contact-files
// of 8192, 128 bytes of command and 512 contacts.
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

bool strsta(char* lego, char* tower) { // dont ask plz
	if (strlen(lego) > strlen(tower)) return false;

	int i;
	for (i = 0; i < strlen(lego); i++) {
		if (lego[i] != tower[i]) return false;
	}

	return true;
}

bool strcomp(char* str1, char* str2) { // never trust strcmp
	if (strlen(str1) != strlen(str2)) return false;
	return strsta(str1, str2);
}

int strcon(char needle, char* haystack) {
	int i, ret = 0;
	for (i = 0; i < strlen(haystack); i++) {
		if (haystack[i] == needle) ret++;
	}
	return ret;
}

struct contact {
	char* name;
	char* number;
	char* address;
};

int main() {
	char* contactsloc = malloc(32);
	snprintf(contactsloc, 32, "%s/contacts", getenv("HOME"));
	FILE* contactfd = fopen(contactsloc, "r");

	if (errno != 0) return printf("%s", strerror(errno)) % 1 + 1;
	free(contactsloc);

	struct contact contacts[512];

	int i = 1; // more user-friendly
	char* line = malloc(8192);
	char* chunk;
	while (fgets(line, 8192, contactfd)) {
		struct contact tmp = { "", "", "" };
		int j;

		for (j = 0; (chunk = strtok(line, "\t")) != NULL; j++, line = NULL) {
			if (j == 0)
				tmp.name = chunk;
			else if (j == 1)
				tmp.number = chunk;
			else if (j == 2)
				tmp.address = chunk;
		}

		contacts[i++] = tmp;
		line = malloc(8192);
	}

	fclose(contactfd);
	free(line);
	free(chunk);

	char* in = malloc(128);
	while (fgets(in, 128, stdin)) {
		if (strcomp(in, "q\n")) {
			exit(0);
		} else if (strcomp(in, "license\n")) {
			puts("phone-cli is (c) 2018 thatlittlegit, and is under \
the GNU General Public License, 3.0 or \
higher.");
		} else {
			if (atoi(in) != 0 || strsta("0", in)) {
				int contact = atoi(in);

				if (contacts[contact].name != NULL) {
					if (strcon(' ', in) == 0) {
						printf("%s\t%s\t%s", contacts[contact].name, contacts[contact].number, contacts[contact].address);
					} else {
						int i;
						char* inp = malloc(128);
						char* part = malloc(128);
						strcpy(inp, in);

						for (i = 0; (part = strtok(inp, " ")); inp = NULL, i++) {
							if (i == 1) {
								if (strcomp(part, "name\n"))
									printf("%s\n", contacts[contact].name);
								else if (strcomp(part, "phone\n"))
									printf("%s\n", contacts[contact].number);
								else if (strcomp(part, "site\n"))
									// newline is already in site address
									printf("%s", contacts[contact].address);
								else
									puts("field not found");
							}
						}
					}
				} else {
					puts("entry not found");
				}
			}
		}
	}
}
```

Result: **49** lines of code (actually 114).

## Shell
```sh
#!/bin/sh
while echo -n 'phone> ' && read in
do
	if [ -z "$in" ]
	then
		echo -n '' # nop
	elif [ "$in" = "q" ]
	then
		exit
	elif [ "$in" = "license" ]
	then
		echo "phone-cli is (c) 2018 thatlittlegit, and is under the GNU General Public License, 3.0 or higher."
	else
		fields=`echo $in | sed 's/[^ ]//g' | wc -c`
		contact=`echo $in | cut -d' ' -f1`
		field=`echo $in | cut -d' ' -f2`

		readfromout() {
			cat -n ~/contacts | sed 's/^ *//g' | grep "^$contact"
		}

		if [ -z "$(readfromout)" ]
		then
			echo "entry not found"
		elif [ $fields -eq 1 ]
		then
			readfromout | cut -f2-4
		else
			if [ "$field" = "name" ]
			then
				readfromout | cut -f2
			elif [ "$field" = "phone" ]
			then
				readfromout | cut -f3
			elif [ "$field" = "site" ]
			then
				readfromout | cut -f4
			else
				echo "field not found"
			fi
		fi
	fi
done
```
<!--
```
fix Vim -->

Result: **41** lines of code (actually 43).

## Conclusion
As you can tell by the "actual" output, the Shell is much shorter. But I think
it goes farther than that.

The Shell script does not (directly) read the file, it has less parenthesises
confusing things. It doesn't deal with 50 .splits, deal with reimplementing
`strcmp(3)` or opening file descriptors. In my *opinion*, the code is cleaner.

In addition, I think Shell is better-equipped to deal with openness. In
JavaScript, it makes more sense to encode data with JSON. JSON is nice, and an
interpreter is available for [basically everything](https://json.org), but it
isn't very human-readable. C... who knows. Yet Shell is best-equipped for TSV,
which is human readable and looks like a spreadsheet,
[which people like](https://www.windowscentral.com/there-are-now-12-billion-office-users-60-million-office-365-commercial-customers).
I think it's also easier to use, since you don't need to install Node or GCC.

So there's my two cents.
